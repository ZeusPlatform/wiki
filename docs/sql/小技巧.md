# 小技巧

## 编程语言

设计一种语言，在这种语言中，告诉机器我们想要的结果是什么（WHAT），而不是如何（HOW）获得. 我们不关心数据库将如何检索这些信息（比如，是先加载用户表呢，还是先加载地址表？这两个表是在嵌套循环中联接呢，还是使用 hashmap 联接？

## 1. 一切都是表

这是一条最微不足道的技巧，甚至不能说是真正的技巧，但它是全面理解 SQL 的基础：一切都是表：当我们看到这样的 SQL 语句时：



```
SELECT *
FROM person
```

……我们很快就能在 FROM 子句中找到 person 表。很好，那是一张表。但我们能意识到整个语句也是一张表吗？例如，我们可以这样写：



```
SELECT *
FROM (
  SELECT *
  FROM person
) t
```

现在，我们已经创建了一张所谓的“派生表”，即 FROM 子句中的嵌套 SELECT 语句。

这是微不足道的，但是如果仔细想想，它是相当优雅的。我们还可以在某些数据库（比如 PostgreSQL、SQL Server）中使用 VALUES() 构造函数来创建临时内存表：



```
SELECT *
FROM (
  VALUES(1),(2),(3)
) t(a)
```

临时表就这样产生了：



```
a
—
1
2
3
```

如果对应的数据库不支持该子句，则可以回到使用派生表上，比如，在 Oracle 中：



```
SELECT *
FROM (
  SELECT 1 AS a FROM DUAL UNION ALL
  SELECT 2 AS a FROM DUAL UNION ALL
  SELECT 3 AS a FROM DUAL
) t
```

既然我们已经看到了 VALUES() 和派生表实际上是相同的，那么从概念上，我们回顾一下 INSERT 语句，它有两种类型：



```
-- SQL Server, PostgreSQL, some others:
INSERT INTO my_table(a)
VALUES(1),(2),(3);
  
-- Oracle, many others:
INSERT INTO my_table(a)
SELECT 1 AS a FROM DUAL UNION ALL
SELECT 2 AS a FROM DUAL UNION ALL
SELECT 3 AS a FROM DUAL
```

在 SQL 中，一切都是表。当您在表中插入行时，实际上并不是插入单独的行。是插入整张表。在大多数情况下，大部分人只是碰巧插入了一张单行表，因此没有意识到 INSERT 真正做了什么。

一切都是表。在 PostgreSQL 中，甚至函数都是表：



```
SELECT *
FROM substring('abcde', 2, 3)
```

上面语句的结果是：



```
substring
———
bcd

```

如果你正在使用 Java 编程，那么可以使用 Java 8 Stream API 来做进一步的类比。考虑如下等价概念：



```
TABLE          : Stream<Tuple<..>>
SELECT         : map() 
DISTINCT       : distinct()
JOIN           : flatMap()
WHERE / HAVING : filter()
GROUP BY       : collect()
ORDER BY       : sorted()
UNION ALL      : concat()
```

在 Java 8 中，“一切都是流”（至少在你开始使用流时是这样）。无论如何转换流，例如，使用 map() 或 filter() 转换，结果类型始终都是流。

我们写了一篇完整的文章来更深入地解释这一点，并将 Stream API 与 SQL 进行了对比：[ Common ](https://blog.jooq.org/2015/08/13/common-sql-clauses-and-their-equivalents-in-java-8-streams)[SQL C ](https://blog.jooq.org/2015/08/13/common-sql-clauses-and-their-equivalents-in-java-8-streams)[lauses and Their Equivalents in Java 8 Streams](https://blog.jooq.org/2015/08/13/common-sql-clauses-and-their-equivalents-in-java-8-streams)

如果你正在寻找“更好的流”（即，具有更多 SQL 语义的流），[请查看 jOOλ](https://github.com/jOOQ/jOOL)，[它一个将SQL 窗口函数引入到Java 中的开源库](https://blog.jooq.org/2016/01/06/2016-will-be-the-year-remembered-as-when-java-finally-had-window-functions/)。

## 2. 使用递归 SQL 生成数据

公共表表达式（Common Table Expressions ，CTE，在 Oracle 中也叫做子查询分解），它是在 SQL 中声明变量的唯一方法（除了模糊 WINDOW 子句之外，WINDOW 子句也只有在 PostgreSQL 和 Sybase SQL 中可用）。

这是一个功能强大的概念。非常强大。考虑如下声明：

复制代码

```
-- 表变量
WITH
  t1(v1, v2) AS (SELECT 1, 2),
  t2(w1, w2) AS (
    SELECT v1 * 2, v2 * 2
    FROM t1
  )
SELECT *
FROM t1, t2
```

它的结果是：

复制代码

```
v1   v2   w1   w2
-----------------
 1    2    2    4
```

使用简单的 WITH 子句，我们可以指定一系列表变量（请记住：一切都是表），这些变量甚至可以是相互依赖的。

这很容易理解。它已经使得 CTE（Common Table Expressions）非常有用了，但是，真正了不起的是，它们还允许递归！考虑如下 PostgreSQL 示例：

复制代码

```
WITH RECURSIVE t(v) AS (
  SELECT 1     -- 种子行
  UNION ALL
  SELECT v + 1 -- 递归
  FROM t
)
SELECT v
FROM t
LIMIT 5
```

它的结果是：

复制代码

```
v
—
1
2
3
4
5
```

它是如何工作的呢？一旦你看懂了一些关键词，它就相对容易了。我们定义了一个公共表表达式，它恰好有两个 UNION ALL 子查询。

第一个 UNION ALL 子查询是我们通常所说的“种子行”。它“播种”（初始化）递归。它可以生成一行或多行，稍后我们将在这些行上递归。记住：一切都是表，所以递归将发生在整张表上，而不是单个行 / 值上。

第二个 UNION ALL 子查询在发生递归的地方。如果你仔细观察，会发现它从 t 中选择。也就是说，允许第二个子查询从我们即将声明的 CTE 中递归地选择。因此，它还可以访问使用它的 CTE 声明的列 v。

在我们的示例中，我们使用行 (1) 对递归进行种子处理，然后通过添加 v + 1 来进行递归。最后通过设置 LIMIT 5 来终止递归（[需要谨防潜在的无限递归 ，就像使用Java 8 的流一样](https://blog.jooq.org/2016/03/29/watch-out-for-recursion-in-java-8s-primitivestream-iterate/)）。

**附注：图灵完备**

递归CTE 使得SQL:1999 图灵完备，这意味着任何程序都可以用SQL 编写！ （如果你够疯狂的话）

一个经常出现在博客上的令人印象深刻的例子是：Mandelbrot 集，如[ http://explainextended.com/2013/12/31/happy-new-year-5/ ](http://explainextended.com/2013/12/31/happy-new-year-5所示/)所示。

复制代码

```
 
WITH RECURSIVE q(r, i, rx, ix, g) AS (
  SELECT r::DOUBLE PRECISION * 0.02, i::DOUBLE PRECISION * 0.02, 
        .0::DOUBLE PRECISION      , .0::DOUBLE PRECISION, 0
  FROM generate_series(-60, 20) r, generate_series(-50, 50) i
  UNION ALL
  SELECT r, i, CASE WHEN abs(rx * rx + ix * ix) &amp;amp;lt;= 2 THEN rx * rx - ix * ix END + r, 
               CASE WHEN abs(rx * rx + ix * ix) &amp;amp;lt;= 2 THEN 2 * rx * ix END + i, g + 1
  FROM q
  WHERE rx IS NOT NULL AND g &amp;amp;lt; 99
)
SELECT array_to_string(array_agg(s ORDER BY r), '')
FROM (
  SELECT i, r, substring(' .:-=+*#%@', max(g) / 10 + 1, 1) s
  FROM q
  GROUP BY i, r
) q
GROUP BY i
ORDER BY i
```

在 PostgreSQL 上运行上面的代码，我们将得到如下结果：

复制代码

```
                             .-.:-.......==..*.=.::-@@@@@:::.:.@..*-.         =. 
                             ...=...=...::+%.@:@@@@@@@@@@@@@+*#=.=:+-.      ..-  
                             .:.:=::*....@@@@@@@@@@@@@@@@@@@@@@@@=@@.....::...:. 
                             ...*@@@@=.@:@@@@@@@@@@@@@@@@@@@@@@@@@@=.=....:...::.
                              .::@@@@@:-@@@@@@@@@@@@@@@@@@@@@@@@@@@@:@..-:@=*:::.
                              .-@@@@@-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.=@@@@=..:
                              ...@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:@@@@@:.. 
                             ....:-*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@::  
                            .....@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@-..  
                          .....@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@-:...  
                         .--:+.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@...  
                         .==@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@-..  
                         ..+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@-#.  
                         ...=+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.. 
                         -.=-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@..:
                        .*%:@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:@-
 .    ..:...           ..-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
..............        ....-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%@=
.--.-.....-=.:..........::@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@..
..=:-....=@+..=.........@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:.
.:+@@::@==@-*:%:+.......:@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.
::@@@-@@@@@@@@@-:=.....:@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:
.:@@@@@@@@@@@@@@@=:.....%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
.:@@@@@@@@@@@@@@@@@-...:@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:-
:@@@@@@@@@@@@@@@@@@@-..%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.
%@@@@@@@@@@@@@@@@@@@-..-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.
@@@@@@@@@@@@@@@@@@@@@::+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@+
@@@@@@@@@@@@@@@@@@@@@@:@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@..
@@@@@@@@@@@@@@@@@@@@@@-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@- 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.  
```

印象是不是非常深刻？

