## 前端缓存/后端缓存
* 请求
* 处理
* 响应

后端缓存主要集中于“处理”步骤，通过保留数据库连接，存储处理结果等方式缩短处理时间，尽快进入“响应”步骤。当然这不在本文的讨论范围之内。

而前端缓存则可以在剩下的两步：“请求”和“响应”中进行。在“请求”步骤中，浏览器也可以通过存储结果的方式直接使用资源，直接省去了发送请求；而“响应”步骤需要浏览器和服务器共同配合，通过减少响应内容来缩短传输时间。这些都会在下面进行讨论。

本文主要包含

* 按缓存位置分类 (memory cache, disk cache, Service Worker 等)
* 按失效策略分类 (Cache-Control, ETag, max-age 等)
* 帮助理解原理的一些案例
* 缓存的应用模式

## HTTP 协议头与缓存位置的关联
HTTP协议头属于disk cache的范畴（这个范畴这么用的么）

### 鉴别
chrome开发这工具 Network -> Size 一列看到一个请求最终的处理方式：如果是大小 (多少 K， 多少 M 等) 就表示是网络请求，否则会列出 from memory cache, from disk cache 和 from ServiceWorker。

### 优先级
它们的优先级是：(由上到下寻找，找到即返回；找不到则继续)

1. Service Worker
2. Memory Cache
3. Disk Cache
4. 网络请求

## memory cache
内存中的缓存（disk cache 硬盘上的缓存）,优先级高，原因计算机优先内存，和**进程**相关

* 几乎所有的网络请求都会被浏览器自动加入到memory cache，**内存有限**，注定**短期存储**
* 通常tab关闭，memory cache即失效
* 极端情况下 (例如一个页面的缓存就占用了超级多的内存)，那可能在 TAB 没关闭之前，排在前面的缓存就已经失效了。
### 如何理解**几乎所有的请求资源都能进入memory cache**
两大模块
1. preloader: 在进行处理阻塞资源的时候，预先加载下一批资源（css渲染阻塞，js解析阻塞）
2. preload： 例如 <link rel="preload">。这些显式指定的预加载资源

## disk cache
硬盘上的缓存，因此它是持久存储的，文件系统。允许相同的资源在跨会话，甚至跨站点的情况下使用
disk cache 会严格根据 HTTP 头信息中的各类字段来判定哪些资源可以缓存，哪些资源不可以缓存；哪些资源是仍然可用的，哪些资源是过时需要重新请求的。当命中缓存之后，浏览器会从硬盘中读取资源，虽然比起从内存中读取慢了一些，但比起网络请求还是快了不少的。绝大部分的缓存都来自 disk cache。

## Service Worker
置响应头的某些字段来告诉浏览器，而不能自己操作
但 Service Worker 的出现，给予了我们另外一种更加灵活，更加直接的操作方式。

即便它并没有命中 Service Worker 缓存，甚至实际走了网络请求，也会标注为 from ServiceWorker。这个情况在后面的第三个示例中有所体现

### Application -> Cache Storage 
### 清除方式
手动调用 API cache.delete(resource) 或者容量超过限制，被浏览器全部清空。

## 请求网络
如果一个请求在Service Worker、Cache Storage 、memory cache都没有找到缓存，那么浏览器会正式发送网络请求去获取内容。之后容易想到，为了提升之后请求的缓存命中率，自然要把这个资源添加到缓存中去。具体来说：

1. 根据 Service Worker 中的 handler 决定是否存入 Cache Storage (额外的缓存位置)。
2. 根据 HTTP 头部的相关字段(Cache-control, Pragma 等)决定是否存入 disk cache
3. memory cache 保存一份资源 的引用，以备下次使用。


缓存小结
当浏览器要请求资源时

1. 调用 Service Worker 的 fetch 事件响应
2. 查看 memory cache
3. 查看 disk cache。这里又细分：
4. 如果有强制缓存且未失效，则使用强制缓存，不请求服务器。这时的状态码全部是 200
5. 如果有强制缓存但已失效，使用对比缓存，比较后确定 304 还是 200


1. 发送网络请求，等待网络响应
2. 把响应内容存入 disk cache (如果 HTTP 头信息配置可以存的话)
3. 把响应内容 的引用 存入 memory cache (无视 HTTP 头信息的配置)
4. 把响应内容存入 Service Worker 的 Cache Storage (如果 Service Worker 的脚本调用了 cache.put())


## 经典HTTP请求
1. 客户端发送请求
2. 服务端响应，在response header加上字段cache-control/expires，Last-Modified/ETag
3. 客户端展示页面，连同header中的字段存储，后续使用
4. 如果有cache-control/expires字段，与客户端时间作对比，判断缓存是否过期， 如果没有过期，使用缓存资源，返回200(from disk cache)或200(from memory cache)，如果已过期，向服务器发送请求
5. 向服务器发送请求时，如果本地有Last-Modified/ETag字段，将上次请求的Last-Modified/Etag一起传递给服务器，与服务器资源作对比，判断上次请求之后资源是否有改变，如果没有改变，返回304和一个空的响应体，否则返回200和新的资源

## 实现200缓存
```
location ~ .*(html|gif|jpg|jpeg|png|bmp|swf|js|css) {
    add_header Cache-control max-age=95800;
}
```

## 禁止缓存
```
location ~ .*(html|gif|jpg|jpeg|png|bmp|swf|js|css) {
    add_header Cache-control no-store;
}
```
## 生产环境强制刷新缓存策略
文件名和文件内容关联起来（hash策略）

## memory cache 和 disk cache 关联
在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。

